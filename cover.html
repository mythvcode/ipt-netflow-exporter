
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>iptnetflowexporter: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/mythvcode/ipt-netflow-exporter/cmd/iptnetflowexporter/main.go (0.0%)</option>
				
				<option value="file1">github.com/mythvcode/ipt-netflow-exporter/internal/config/config.go (69.2%)</option>
				
				<option value="file2">github.com/mythvcode/ipt-netflow-exporter/internal/config/config_validator.go (100.0%)</option>
				
				<option value="file3">github.com/mythvcode/ipt-netflow-exporter/internal/exporter/collector.go (85.7%)</option>
				
				<option value="file4">github.com/mythvcode/ipt-netflow-exporter/internal/exporter/common_metrics.go (100.0%)</option>
				
				<option value="file5">github.com/mythvcode/ipt-netflow-exporter/internal/exporter/cpu_metrics.go (100.0%)</option>
				
				<option value="file6">github.com/mythvcode/ipt-netflow-exporter/internal/exporter/exporter.go (53.8%)</option>
				
				<option value="file7">github.com/mythvcode/ipt-netflow-exporter/internal/exporter/exporter_test_helpers.go (100.0%)</option>
				
				<option value="file8">github.com/mythvcode/ipt-netflow-exporter/internal/exporter/mocks/mock_StatParser.go (0.0%)</option>
				
				<option value="file9">github.com/mythvcode/ipt-netflow-exporter/internal/exporter/socket_metrics.go (100.0%)</option>
				
				<option value="file10">github.com/mythvcode/ipt-netflow-exporter/internal/logger/discard_logger.go (0.0%)</option>
				
				<option value="file11">github.com/mythvcode/ipt-netflow-exporter/internal/logger/logger.go (0.0%)</option>
				
				<option value="file12">github.com/mythvcode/ipt-netflow-exporter/internal/statparser/statistic.go (83.9%)</option>
				
				<option value="file13">github.com/mythvcode/ipt-netflow-exporter/internal/statparser/statistic_parser.go (92.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "errors"
        "flag"
        "net/http"
        "os"
        "os/signal"
        "syscall"

        "github.com/mythvcode/ipt-netflow-exporter/internal/config"
        "github.com/mythvcode/ipt-netflow-exporter/internal/exporter"
        "github.com/mythvcode/ipt-netflow-exporter/internal/logger"
        "github.com/mythvcode/ipt-netflow-exporter/internal/statparser"
)

var cfgPath string

func init() <span class="cov0" title="0">{
        flag.StringVar(&amp;cfgPath, "config", "", "Path to config file")
}</span>

func main() <span class="cov0" title="0">{
        sigs := make(chan os.Signal, 1)
        signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)
        flag.Parse()
        cfg, err := config.ReadConfig(cfgPath)
        if err != nil </span><span class="cov0" title="0">{
                if cfgPath != "" </span><span class="cov0" title="0">{
                        logger.Default().Errorf("Error read config file from file %s: %s", cfgPath, err.Error())
                }</span> else<span class="cov0" title="0"> {
                        logger.Default().Errorf("Error read config: %s", err.Error())
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }

        <span class="cov0" title="0">if err := logger.Init(cfg.Logger.File, cfg.Logger.Level, cfg.Logger.Format); err != nil </span><span class="cov0" title="0">{
                logger.Default().Errorf("error init logger %s", err.Error())
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">stat := statparser.New(cfg.Exporter.IPTNetFlowStatFile)
        exporter, err := exporter.New(cfg.Exporter, stat)
        if err != nil </span><span class="cov0" title="0">{
                logger.GetLogger().Errorf("error init exporter %s", err.Error())
        }</span>
        <span class="cov0" title="0">started := make(chan error)
        go func() </span><span class="cov0" title="0">{
                started &lt;- exporter.Start()
        }</span>()
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if err := &lt;-started; err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        logger.GetLogger().Errorf("Error start exporter: %s", err.Error())
                        os.Exit(1)
                }</span>
        }()

        <span class="cov0" title="0">defer exporter.Stop()
        &lt;-sigs</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "context"
        "fmt"
        "os"
        "path/filepath"

        "github.com/creasty/defaults"
        "github.com/sethvargo/go-envconfig"
        "gopkg.in/yaml.v3"
)

type Config struct {
        Logger   Logger   `env:", prefix=EXPORTER_" yaml:"logger"`
        Exporter Exporter `env:", prefix=EXPORTER_" yaml:"exporter"`
}

type Logger struct {
        Format string `default:"json"  env:"LOG_FORMAT" yaml:"format"`
        Level  string `default:"debug" env:"LOG_LEVEL"  yaml:"level"`
        File   string `default:""      env:"LOG_FILE"   yaml:"file"`
}

type Exporter struct {
        ServerAddress        string `default:"localhost"                       env:"HOST"                   yaml:"server_address"`
        ServerPort           int    `default:"8080"                            env:"PORT"                   yaml:"server_port"`
        RequestTimeout       int    `default:"10"                              env:"REQUEST_TIMEOUT"        yaml:"request_timeout"`
        TelemetryPath        string `default:"/metrics"                        env:"TELEMETRY_PATH"         yaml:"telemetry_path"`
        IPTNetFlowStatFile   string `default:"/proc/net/stat/ipt_netflow_snmp" env:"IPT_NETFLOW_STAT"       yaml:"ipt_netflow_stat"`
        EnableRuntimeMetrics bool   `default:"false"                           env:"ENABLE_RUNTIME_METRICS" yaml:"enable_runtime_metrics"`
}

func (c *Config) UnmarshalYAML(unmarshal func(interface{}) error) error <span class="cov8" title="1">{
        if err := defaults.Set(c); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">type plain Config

        return unmarshal((*plain)(c))</span>
}

func ReadEnv(cfg Config) (Config, error) <span class="cov8" title="1">{
        err := envconfig.Process(
                context.Background(),
                &amp;envconfig.Config{DefaultOverwrite: true, Target: &amp;cfg},
        )

        return cfg, err
}</span>

func ReadConfig(file string) (Config, error) <span class="cov8" title="1">{
        var err error
        var cfg Config
        if file == "" </span><span class="cov8" title="1">{
                cfg, err = ReadEnv(getDefault())
        }</span> else<span class="cov0" title="0"> {
                cfg, err = loadFromFile(file)
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return cfg, err
        }</span>

        <span class="cov8" title="1">return ValidateConfig(cfg)</span>
}

func loadFromFile(file string) (Config, error) <span class="cov0" title="0">{
        configBytes, err := os.ReadFile(filepath.Clean(file))
        if err != nil </span><span class="cov0" title="0">{
                return Config{}, fmt.Errorf("unable to read config: %w", err)
        }</span>

        <span class="cov0" title="0">return loadFromBytes(configBytes)</span>
}

func getDefault() Config <span class="cov8" title="1">{
        res, _ := loadFromBytes([]byte{})

        return res
}</span>

func loadFromBytes(data []byte) (Config, error) <span class="cov8" title="1">{
        var config Config

        // make empty config for defaults package to call function UnmarshalYAML
        if len(data) == 0 </span><span class="cov8" title="1">{
                data = []byte("exporter:")
        }</span>

        <span class="cov8" title="1">if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return Config{}, fmt.Errorf("unable to unmarshal config: %w", err)
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "fmt"
        "net"
        "slices"
)

type validateFunction func(c *Config) error

var logLevels = []string{"debug", "info", "warning", "error"}

var logFormats = []string{"text", "json"}

var validatorList = []validateFunction{
        validateLogLevel,
        validatePort,
        validateIP,
        validateLogFormat,
}

func ValidateConfig(cfg Config) (Config, error) <span class="cov8" title="1">{
        for _, vFunc := range validatorList </span><span class="cov8" title="1">{
                if err := vFunc(&amp;cfg); err != nil </span><span class="cov8" title="1">{
                        return cfg, err
                }</span>
        }

        <span class="cov8" title="1">return cfg, nil</span>
}

func validateLogLevel(cfg *Config) error <span class="cov8" title="1">{
        if !slices.Contains(logLevels, cfg.Logger.Level) </span><span class="cov8" title="1">{
                return fmt.Errorf("error incorrect log level %s", cfg.Logger.Level)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func validatePort(cfg *Config) error <span class="cov8" title="1">{
        if cfg.Exporter.ServerPort &lt; 1 || cfg.Exporter.ServerPort &gt; 65535 </span><span class="cov8" title="1">{
                return fmt.Errorf("error incorrect port number %d", cfg.Exporter.ServerPort)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func validateIP(cfg *Config) error <span class="cov8" title="1">{
        if cfg.Exporter.ServerAddress != "localhost" &amp;&amp; net.ParseIP(cfg.Exporter.ServerAddress) == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("error incorrect ip address %s", cfg.Exporter.ServerAddress)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func validateLogFormat(cfg *Config) error <span class="cov8" title="1">{
        if !slices.Contains(logFormats, cfg.Logger.Format) </span><span class="cov8" title="1">{
                return fmt.Errorf("error incorrect log format %s", cfg.Logger.Format)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package exporter

import (
        "log/slog"

        "github.com/mythvcode/ipt-netflow-exporter/internal/logger"
        "github.com/mythvcode/ipt-netflow-exporter/internal/statparser"
        "github.com/prometheus/client_golang/prometheus"
)

const metricsNamespace = "ipt_netflow"

type iptNetFlowMetric interface {
        prometheus.Collector
        Reset()
}

type iptNetFlowCollectors interface {
        prometheus.Collector
        updateValues(stat *statparser.Statistics)
}

type IPTNetFlowTCollector struct {
        statParser    StatParser
        log           *logger.Logger
        commonMetrics *CommonMetrics
        cpuMetrics    *CPUMetrics
        sockMetrics   *SockMetrics
}

func (i *IPTNetFlowTCollector) Name() string <span class="cov0" title="0">{
        return "ipt-netflow-collector"
}</span>

func newIPTNetFlowTCollector(stat StatParser) *IPTNetFlowTCollector <span class="cov8" title="1">{
        return &amp;IPTNetFlowTCollector{
                statParser:    stat,
                log:           logger.GetLogger().With(slog.String(logger.Component, "IPTNetFlowTCollector")),
                commonMetrics: newCommonMetricsCollector(),
                cpuMetrics:    NewCPUMetrics(),
                sockMetrics:   newSocketMetrics(),
        }
}</span>

func (i *IPTNetFlowTCollector) Initialized() bool <span class="cov8" title="1">{
        return !(i.statParser == nil &amp;&amp; i.log != nil)
}</span>

func (i *IPTNetFlowTCollector) collectorList() []iptNetFlowCollectors <span class="cov8" title="1">{
        return []iptNetFlowCollectors{
                i.commonMetrics,
                i.cpuMetrics,
                i.sockMetrics,
        }
}</span>

func (i *IPTNetFlowTCollector) Collect(metricChan chan&lt;- prometheus.Metric) <span class="cov8" title="1">{
        metrics, err := i.statParser.CollectAndMarshal()
        if err != nil </span><span class="cov0" title="0">{
                i.log.Errorf("error collect metrics: %s", err.Error())
                </span>return
        }

        collectors := i.collectorList()

</span>        for _, collector := range collectors {
                </span>collector.updateValues(&amp;metrics)
        <span class="cov8" title="1">}
</span>        for _, collector := range collectors {
                </span>collector.Collect(metricChan)
        }
}

func (i *IPTNetFlowTCollector) Describe(ch ch</span><span class="cov8" title="1">an&lt;- *prometheus.Desc) {
        for _, collector := range i.collectorList() {
                </span>collector.Describe(ch)
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package exporter

import (
        "github.com/mythvcode/ipt-netflow-exporter/internal/statparser"
        "github.com/prometheus/client_golang/prometheus"
)

type CommonMetrics struct {
        inBitRate    *prometheus.GaugeVec
        inPacketRate *prometheus.GaugeVec
        inFlows      *prometheus.CounterVec
        inPackets    *prometheus.CounterVec
        inBytes      *prometheus.CounterVec
        hashMetric   *prometheus.GaugeVec
        hashMemory   *prometheus.GaugeVec
        hashFlows    *prometheus.GaugeVec
        hashPackets  *prometheus.GaugeVec
        hashBytes    *prometheus.GaugeVec
        dropPackets  *prometheus.CounterVec
        dropBytes    *prometheus.CounterVec
        outByteRate  *prometheus.GaugeVec
        outFlows     *prometheus.CounterVec
        outPackets   *prometheus.CounterVec
        outBytes     *prometheus.CounterVec
        lostFlows    *prometheus.CounterVec
        lostPackets  *prometheus.CounterVec
        lostBytes    *prometheus.CounterVec
        errTotal     *prometheus.CounterVec
        sndbufPeak   *prometheus.CounterVec
}

func newCommonMetricsCollector() *CommonMetrics <span class="cov8" title="1">{
        metrics := CommonMetrics{
                inBitRate: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Namespace: metricsNamespace,
                                Name:      "in_bit_rate",
                                Help:      "Total incoming bits per second.",
                        }, []string{},
                ),
                inPacketRate: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Namespace: metricsNamespace,
                                Name:      "in_packet_rate",
                                Help:      "Total incoming packets per second.",
                        }, []string{},
                ),
                inFlows: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "in_flows",
                                Help:      "Total observed (metered) flow.",
                        }, []string{},
                ),
                inPackets: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "in_packets",
                                Help:      "Total metered packets. Not counting dropped packets.",
                        }, []string{},
                ),
                inBytes: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "in_bytes",
                                Help:      "Total metered bytes in inPackets.",
                        }, []string{},
                ),
                hashMetric: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Namespace: metricsNamespace,
                                Name:      "hash_metrics",
                                Help:      "Measure of performance of hash table. When optimal should attract to 1.0, when non-optimal will be highly above of 1.",
                        }, []string{},
                ),
                hashMemory: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Namespace: metricsNamespace,
                                Name:      "hash_memory",
                                Help:      "How much system memory is used by the hash table.",
                        }, []string{},
                ),
                hashFlows: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Namespace: metricsNamespace,
                                Name:      "hash_flows",
                                Help:      "Flows currently residing in the hash table and not exported yet.",
                        }, []string{},
                ),
                hashPackets: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Namespace: metricsNamespace,
                                Name:      "hash_packets",
                                Help:      "Packets in flows currently residing in the hash table.",
                        }, []string{},
                ),
                hashBytes: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Namespace: metricsNamespace,
                                Name:      "hash_bytes",
                                Help:      "Bytes in flows currently residing in the hash table.",
                        }, []string{},
                ),
                dropPackets: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "drop_packets",
                                Help:      "Total packets dropped by metering process.",
                        }, []string{},
                ),
                dropBytes: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "drop_bytes",
                                Help:      "Total bytes in packets dropped by metering process.",
                        }, []string{},
                ),
                outByteRate: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Namespace: metricsNamespace,
                                Name:      "out_byte_rate",
                                Help:      "Total exporter output bytes per second.",
                        }, []string{},
                ),
                outFlows: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "drop_flows",
                                Help:      "Total exported flow data records.",
                        }, []string{},
                ),
                outPackets: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "out_packets",
                                Help:      "Total exported packets of netflow stream itself.",
                        }, []string{},
                ),
                outBytes: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "out_bytes",
                                Help:      "Total exported bytes of netflow stream itself.",
                        }, []string{},
                ),
                lostFlows: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "lost_flows",
                                Help:      "Total of accounted flows that are lost by exporting process due to socket errors. This value will not include asynchronous errors (cberr), these will be counted in err_total.",
                        }, []string{},
                ),
                lostPackets: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "lost_packets",
                                Help:      "Total metered packets lost by exporting process. See lost_flows for details.",
                        }, []string{},
                ),
                lostBytes: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "lost_bytes",
                                Help:      "Total bytes in packets lost by exporting process. See lost_flows for details.",
                        }, []string{},
                ),
                errTotal: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "lost_total",
                                Help:      "Total exporting sockets errors (including cberr).",
                        }, []string{},
                ),
                sndbufPeak: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "sndbuf_peak",
                                Help:      "Global maximum value of socket sndbuf. Sort of outputqueue length.",
                        }, []string{},
                ),
        }

        return &amp;metrics
}</span>

func (c *CommonMetrics) metricList() []iptNetFlowMetric <span class="cov8" title="1">{
        return []iptNetFlowMetric{
                c.inBitRate,
                c.inPacketRate,
                c.inFlows,
                c.inPackets,
                c.inBytes,
                c.hashMetric,
                c.hashMemory,
                c.hashFlows,
                c.hashPackets,
                c.hashBytes,
                c.dropPackets,
                c.dropBytes,
                c.outByteRate,
                c.outFlows,
                c.outPackets,
                c.outBytes,
                c.lostFlows,
                c.lostPackets,
                c.lostBytes,
                c.errTotal,
                c.sndbufPeak,
        }
}</span>

func (c *CommonMetrics) reset() <span class="cov8" title="1">{
        for _, metric := range c.metricList() </span><span class="cov8" title="1">{
                metric.Reset()
        }</span>
}

func (c *CommonMetrics) updateValues(stat *statparser.Statistics) <span class="cov8" title="1">{
        c.reset()

        c.inBitRate.With(prometheus.Labels{}).Set(float64(stat.InBitRate))
        c.inPacketRate.With(prometheus.Labels{}).Set(float64(stat.InPacketRate))
        c.inFlows.With(prometheus.Labels{}).Add(float64(stat.InBitRate))
        c.inPackets.With(prometheus.Labels{}).Add(float64(stat.InPackets))
        c.inBytes.With(prometheus.Labels{}).Add(float64(stat.InBytes))
        c.hashMetric.With(prometheus.Labels{}).Set(stat.HashMetric)
        c.hashMemory.With(prometheus.Labels{}).Set(float64(stat.HashMemory))
        c.hashFlows.With(prometheus.Labels{}).Set(float64(stat.HashFlows))
        c.hashPackets.With(prometheus.Labels{}).Set(float64(stat.HashPackets))
        c.hashBytes.With(prometheus.Labels{}).Set(float64(stat.HashBytes))
        c.dropPackets.With(prometheus.Labels{}).Add(float64(stat.DropPackets))
        c.dropBytes.With(prometheus.Labels{}).Add(float64(stat.DropBytes))
        c.outByteRate.With(prometheus.Labels{}).Set(float64(stat.OutByteRate))
        c.outFlows.With(prometheus.Labels{}).Add(float64(stat.OutFlows))
        c.outPackets.With(prometheus.Labels{}).Add(float64(stat.OutPackets))
        c.outBytes.With(prometheus.Labels{}).Add(float64(stat.OutBytes))
        c.lostFlows.With(prometheus.Labels{}).Add(float64(stat.LostFlows))
        c.lostPackets.With(prometheus.Labels{}).Add(float64(stat.LostPackets))
        c.lostBytes.With(prometheus.Labels{}).Add(float64(stat.LostBytes))
        c.errTotal.With(prometheus.Labels{}).Add(float64(stat.ErrTotal))
        c.sndbufPeak.With(prometheus.Labels{}).Add(float64(stat.ErrTotal))
}</span>

func (c *CommonMetrics) Describe(ch chan&lt;- *prometheus.Desc) <span class="cov8" title="1">{
        for _, metric := range c.metricList() </span><span class="cov8" title="1">{
                metric.Describe(ch)
        }</span>
}

func (c *CommonMetrics) Collect(metricChan chan&lt;- prometheus.Metric) <span class="cov8" title="1">{
        for _, metric := range c.metricList() </span><span class="cov8" title="1">{
                metric.Collect(metricChan)
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package exporter

import (
        "github.com/mythvcode/ipt-netflow-exporter/internal/statparser"
        "github.com/prometheus/client_golang/prometheus"
)

const cpuLabel = "cpu"

type CPUMetrics struct {
        cpuInPacketRate prometheus.GaugeVec
        cpuInFlows      prometheus.CounterVec
        cpuInPackets    prometheus.CounterVec
        cpuInBytes      prometheus.CounterVec
        cpuHashMetric   prometheus.GaugeVec
        cpuDropPackets  prometheus.CounterVec
        cpuDropBytes    prometheus.CounterVec
        cpuErrTrunc     prometheus.CounterVec
        cpuErrFrag      prometheus.CounterVec
        cpuErrAlloc     prometheus.CounterVec
        cpuErrMaxFlows  prometheus.CounterVec
}

func NewCPUMetrics() *CPUMetrics <span class="cov8" title="1">{
        return &amp;CPUMetrics{
                cpuInPacketRate: *prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Namespace: metricsNamespace,
                                Name:      "cpu_in_packet_rate",
                                Help:      "Incoming packets per second for this cpu.",
                        }, []string{cpuLabel},
                ),
                cpuInFlows: *prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "cpu_in_flows",
                                Help:      "Flows metered on this cpu.",
                        }, []string{cpuLabel},
                ),
                cpuInPackets: *prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "cpu_in_packets",
                                Help:      "Packets metered for cpu.",
                        }, []string{cpuLabel},
                ),
                cpuInBytes: *prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "cpu_in_bytes",
                                Help:      "Bytes metered on this cpu.",
                        }, []string{cpuLabel},
                ),
                cpuHashMetric: *prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Namespace: metricsNamespace,
                                Name:      "cpu_hash_metric",
                                Help:      "Measure of performance of hash table on this cpu.",
                        }, []string{cpuLabel},
                ),
                cpuDropPackets: *prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "cpu_drop_packets",
                                Help:      "Packets dropped by metering process on this cpu.",
                        }, []string{cpuLabel},
                ),
                cpuDropBytes: *prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "cpu_drop_bytes",
                                Help:      "Bytes in cpu_drop_packets for this cpu.",
                        }, []string{cpuLabel},
                ),
                cpuErrTrunc: *prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "cpu_err_trunc",
                                Help:      "Truncated packets dropped for this cpu.",
                        }, []string{cpuLabel},
                ),
                cpuErrFrag: *prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "cpu_err_flag",
                                Help:      "Fragmented packets dropped for this cpu.",
                        }, []string{cpuLabel},
                ),
                cpuErrAlloc: *prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "cpu_err_alloc",
                                Help:      "Packets dropped due to memory allocation errors.",
                        }, []string{cpuLabel},
                ),
                cpuErrMaxFlows: *prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "cpu_err_max_flows",
                                Help:      "Packets dropped due to maxflows limit being reached.",
                        }, []string{cpuLabel},
                ),
        }
}</span>

func (c *CPUMetrics) metricList() []iptNetFlowMetric <span class="cov8" title="1">{
        return []iptNetFlowMetric{
                c.cpuInPacketRate,
                c.cpuInFlows,
                c.cpuInPackets,
                c.cpuInBytes,
                c.cpuHashMetric,
                c.cpuDropPackets,
                c.cpuDropBytes,
                c.cpuErrTrunc,
                c.cpuErrFrag,
                c.cpuErrAlloc,
                c.cpuErrMaxFlows,
        }
}</span>

func (c *CPUMetrics) reset() <span class="cov8" title="1">{
        for _, metric := range c.metricList() </span><span class="cov8" title="1">{
                metric.Reset()
        }</span>
}

func (c *CPUMetrics) updateValues(stat *statparser.Statistics) <span class="cov8" title="1">{
        c.reset()

        for _, cpuStat := range stat.CPUStatList </span><span class="cov8" title="1">{
                c.cpuInPacketRate.With(prometheus.Labels{cpuLabel: cpuStat.CPU}).Set(float64(cpuStat.CPUInPacketRate))
                c.cpuInFlows.With(prometheus.Labels{cpuLabel: cpuStat.CPU}).Add(float64(cpuStat.CPUInFlows))
                c.cpuInPackets.With(prometheus.Labels{cpuLabel: cpuStat.CPU}).Add(float64(cpuStat.CPUInPackets))
                c.cpuInBytes.With(prometheus.Labels{cpuLabel: cpuStat.CPU}).Add(float64(cpuStat.CPUInBytes))
                c.cpuHashMetric.With(prometheus.Labels{cpuLabel: cpuStat.CPU}).Set(float64(cpuStat.CPUHashMetric))
                c.cpuDropPackets.With(prometheus.Labels{cpuLabel: cpuStat.CPU}).Add(float64(cpuStat.CPUDropPackets))
                c.cpuDropBytes.With(prometheus.Labels{cpuLabel: cpuStat.CPU}).Add(float64(cpuStat.CPUuDropBytes))
                c.cpuErrTrunc.With(prometheus.Labels{cpuLabel: cpuStat.CPU}).Add(float64(cpuStat.CPUErrTrunc))
                c.cpuErrFrag.With(prometheus.Labels{cpuLabel: cpuStat.CPU}).Add(float64(cpuStat.CPUErrFrag))
                c.cpuErrAlloc.With(prometheus.Labels{cpuLabel: cpuStat.CPU}).Add(float64(cpuStat.CPUErrAlloc))
                c.cpuErrMaxFlows.With(prometheus.Labels{cpuLabel: cpuStat.CPU}).Add(float64(cpuStat.CPUErrMaxflows))
        }</span>
}

func (c *CPUMetrics) Describe(ch chan&lt;- *prometheus.Desc) <span class="cov8" title="1">{
        for _, metric := range c.metricList() </span><span class="cov8" title="1">{
                metric.Describe(ch)
        }</span>
}

func (c *CPUMetrics) Collect(metricChan chan&lt;- prometheus.Metric) <span class="cov8" title="1">{
        for _, metric := range c.metricList() </span><span class="cov8" title="1">{
                metric.Collect(metricChan)
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package exporter

import (
        "fmt"
        slog "log/slog"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/mythvcode/ipt-netflow-exporter/internal/config"
        "github.com/mythvcode/ipt-netflow-exporter/internal/logger"
        "github.com/mythvcode/ipt-netflow-exporter/internal/statparser"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/collectors"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

type StatParser interface {
        CollectAndMarshal() (statparser.Statistics, error)
}

type APIServer struct {
        server *http.Server
        log    *logger.Logger
        config config.Exporter
}

func New(cfg config.Exporter, stat StatParser) (*APIServer, error) <span class="cov8" title="1">{
        apiServer := APIServer{
                log:    logger.GetLogger().With(slog.String(logger.Component, "exporter-api-server")),
                config: cfg,
        }
        collector := newIPTNetFlowTCollector(stat)
        if !collector.Initialized() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("collector %s was not initialized", collector.Name())
        }</span>
        <span class="cov8" title="1">if err := prometheus.Register(collector); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">httpMux := http.NewServeMux()
        timeout := time.Duration(cfg.RequestTimeout) * time.Second
        address := strings.Join([]string{cfg.ServerAddress, strconv.Itoa(cfg.ServerPort)}, ":")
        apiServer.server = &amp;http.Server{
                Addr:         address,
                Handler:      httpMux,
                ReadTimeout:  timeout,
                WriteTimeout: timeout,
                IdleTimeout:  timeout,
        }
        httpMux.HandleFunc("/", apiServer.indexPage)
        httpMux.Handle(cfg.TelemetryPath, apiServer.middlewareLogging(promhttp.Handler()))
        if !cfg.EnableRuntimeMetrics </span><span class="cov8" title="1">{
                prometheus.Unregister(collectors.NewGoCollector())
        }</span>

        <span class="cov8" title="1">return &amp;apiServer, nil</span>
}

func (s *APIServer) middlewareLogging(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(respwr http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                s.log.With(
                        slog.String("addr", req.RemoteAddr),
                        slog.String("method", req.Method),
                        slog.String("agent", req.UserAgent()),
                ).Debugf("%s", req.URL.Path)

                next.ServeHTTP(respwr, req)
        }</span>)
}

// StartAPIServer starts Exporter's HTTP server.
func (s *APIServer) Start() error <span class="cov0" title="0">{
        s.log.Infof("Starting exporter API server on %s", s.server.Addr)

        return s.server.ListenAndServe()
}</span>

func (s *APIServer) Stop() <span class="cov0" title="0">{
        s.log.Infof("Stopping exporter API server")
        if err := s.server.Close(); err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("Error stop exporter")
        }</span>
}

func (s *APIServer) indexPage(w http.ResponseWriter, _ *http.Request) <span class="cov0" title="0">{
        _, err := w.Write([]byte(`&lt;html&gt;
&lt;head&gt;&lt;title&gt;ipt-netflow Exporter&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;ipt-netflow Exporter&lt;/h1&gt;
&lt;p&gt;&lt;a href='` + s.config.TelemetryPath + `'&gt;Metrics&lt;/a&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;`))
        if err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("error handling index page: %s", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package exporter

import (
        "testing"

        "github.com/mythvcode/ipt-netflow-exporter/internal/statparser"
)

func getTestStatistic(t *testing.T) statparser.Statistics <span class="cov8" title="1">{
        t.Helper()

        return statparser.Statistics{
                InBitRate:    1,
                InPacketRate: 2,
                InFlows:      3,
                InPackets:    4,
                InBytes:      5,
                HashMetric:   5.5,
                HashMemory:   6,
                HashFlows:    7,
                HashPackets:  8,
                HashBytes:    9,
                DropPackets:  10,
                DropBytes:    11,
                OutByteRate:  12,
                OutFlows:     13,
                OutPackets:   14,
                OutBytes:     15,
                LostFlows:    16,
                LostPackets:  17,
                LostBytes:    18,
                ErrTotal:     19,
                SndbufPeak:   20,
                CPUStatList: []statparser.CPUStat{
                        {
                                CPU:             "cpu0",
                                CPUInPacketRate: 1,
                                CPUInFlows:      2,
                                CPUInPackets:    3,
                                CPUInBytes:      4,
                                CPUHashMetric:   5.55,
                                CPUDropPackets:  6,
                                CPUuDropBytes:   7,
                                CPUErrTrunc:     8,
                                CPUErrFrag:      9,
                                CPUErrAlloc:     10,
                                CPUErrMaxflows:  11,
                        },
                },
                SockStatList: []statparser.NFSockEntry{
                        {
                                SockName:        "sock0",
                                SockDestination: "localhost:1234",
                                SockActive:      1,
                                SockErrConnect:  2,
                                SockErrFull:     3,
                                SockErrCberr:    4,
                                SockErrOther:    5,
                                SockSndbuf:      6,
                                SockSndbufFill:  7,
                                SockSndbufPeak:  8,
                        },
                },
        }
}</span>

func getPromTestStat(t *testing.T) string <span class="cov8" title="1">{
        return `
        # HELP ipt_netflow_cpu_drop_bytes Bytes in cpu_drop_packets for this cpu.
        # TYPE ipt_netflow_cpu_drop_bytes counter
        ipt_netflow_cpu_drop_bytes{cpu="cpu0"} 7
        # HELP ipt_netflow_cpu_drop_packets Packets dropped by metering process on this cpu.
        # TYPE ipt_netflow_cpu_drop_packets counter
        ipt_netflow_cpu_drop_packets{cpu="cpu0"} 6
        # HELP ipt_netflow_cpu_err_alloc Packets dropped due to memory allocation errors.
        # TYPE ipt_netflow_cpu_err_alloc counter
        ipt_netflow_cpu_err_alloc{cpu="cpu0"} 10
        # HELP ipt_netflow_cpu_err_flag Fragmented packets dropped for this cpu.
        # TYPE ipt_netflow_cpu_err_flag counter
        ipt_netflow_cpu_err_flag{cpu="cpu0"} 9
        # HELP ipt_netflow_cpu_err_max_flows Packets dropped due to maxflows limit being reached.
        # TYPE ipt_netflow_cpu_err_max_flows counter
        ipt_netflow_cpu_err_max_flows{cpu="cpu0"} 11
        # HELP ipt_netflow_cpu_err_trunc Truncated packets dropped for this cpu.
        # TYPE ipt_netflow_cpu_err_trunc counter
        ipt_netflow_cpu_err_trunc{cpu="cpu0"} 8
        # HELP ipt_netflow_cpu_hash_metric Measure of performance of hash table on this cpu.
        # TYPE ipt_netflow_cpu_hash_metric gauge
        ipt_netflow_cpu_hash_metric{cpu="cpu0"} 5.55
        # HELP ipt_netflow_cpu_in_bytes Bytes metered on this cpu.
        # TYPE ipt_netflow_cpu_in_bytes counter
        ipt_netflow_cpu_in_bytes{cpu="cpu0"} 4
        # HELP ipt_netflow_cpu_in_flows Flows metered on this cpu.
        # TYPE ipt_netflow_cpu_in_flows counter
        ipt_netflow_cpu_in_flows{cpu="cpu0"} 2
        # HELP ipt_netflow_cpu_in_packet_rate Incoming packets per second for this cpu.
        # TYPE ipt_netflow_cpu_in_packet_rate gauge
        ipt_netflow_cpu_in_packet_rate{cpu="cpu0"} 1
        # HELP ipt_netflow_cpu_in_packets Packets metered for cpu.
        # TYPE ipt_netflow_cpu_in_packets counter
        ipt_netflow_cpu_in_packets{cpu="cpu0"} 3
        # HELP ipt_netflow_drop_bytes Total bytes in packets dropped by metering process.
        # TYPE ipt_netflow_drop_bytes counter
        ipt_netflow_drop_bytes 11
        # HELP ipt_netflow_drop_flows Total exported flow data records.
        # TYPE ipt_netflow_drop_flows counter
        ipt_netflow_drop_flows 13
        # HELP ipt_netflow_drop_packets Total packets dropped by metering process.
        # TYPE ipt_netflow_drop_packets counter
        ipt_netflow_drop_packets 10
        # HELP ipt_netflow_hash_bytes Bytes in flows currently residing in the hash table.
        # TYPE ipt_netflow_hash_bytes gauge
        ipt_netflow_hash_bytes 9
        # HELP ipt_netflow_hash_flows Flows currently residing in the hash table and not exported yet.
        # TYPE ipt_netflow_hash_flows gauge
        ipt_netflow_hash_flows 7
        # HELP ipt_netflow_hash_memory How much system memory is used by the hash table.
        # TYPE ipt_netflow_hash_memory gauge
        ipt_netflow_hash_memory 6
        # HELP ipt_netflow_hash_metrics Measure of performance of hash table. When optimal should attract to 1.0, when non-optimal will be highly above of 1.
        # TYPE ipt_netflow_hash_metrics gauge
        ipt_netflow_hash_metrics 5.5
        # HELP ipt_netflow_hash_packets Packets in flows currently residing in the hash table.
        # TYPE ipt_netflow_hash_packets gauge
        ipt_netflow_hash_packets 8
        # HELP ipt_netflow_in_bit_rate Total incoming bits per second.
        # TYPE ipt_netflow_in_bit_rate gauge
        ipt_netflow_in_bit_rate 1
        # HELP ipt_netflow_in_bytes Total metered bytes in inPackets.
        # TYPE ipt_netflow_in_bytes counter
        ipt_netflow_in_bytes 5
        # HELP ipt_netflow_in_flows Total observed (metered) flow.
        # TYPE ipt_netflow_in_flows counter
        ipt_netflow_in_flows 1
        # HELP ipt_netflow_in_packet_rate Total incoming packets per second.
        # TYPE ipt_netflow_in_packet_rate gauge
        ipt_netflow_in_packet_rate 2
        # HELP ipt_netflow_in_packets Total metered packets. Not counting dropped packets.
        # TYPE ipt_netflow_in_packets counter
        ipt_netflow_in_packets 4
        # HELP ipt_netflow_lost_bytes Total bytes in packets lost by exporting process. See lost_flows for details.
        # TYPE ipt_netflow_lost_bytes counter
        ipt_netflow_lost_bytes 18
        # HELP ipt_netflow_lost_flows Total of accounted flows that are lost by exporting process due to socket errors. This value will not include asynchronous errors (cberr), these will be counted in err_total.
        # TYPE ipt_netflow_lost_flows counter
        ipt_netflow_lost_flows 16
        # HELP ipt_netflow_lost_packets Total metered packets lost by exporting process. See lost_flows for details.
        # TYPE ipt_netflow_lost_packets counter
        ipt_netflow_lost_packets 17
        # HELP ipt_netflow_lost_total Total exporting sockets errors (including cberr).
        # TYPE ipt_netflow_lost_total counter
        ipt_netflow_lost_total 19
        # HELP ipt_netflow_out_byte_rate Total exporter output bytes per second.
        # TYPE ipt_netflow_out_byte_rate gauge
        ipt_netflow_out_byte_rate 12
        # HELP ipt_netflow_out_bytes Total exported bytes of netflow stream itself.
        # TYPE ipt_netflow_out_bytes counter
        ipt_netflow_out_bytes 15
        # HELP ipt_netflow_out_packets Total exported packets of netflow stream itself.
        # TYPE ipt_netflow_out_packets counter
        ipt_netflow_out_packets 14
        # HELP ipt_netflow_sndbuf_peak Global maximum value of socket sndbuf. Sort of outputqueue length.
        # TYPE ipt_netflow_sndbuf_peak counter
        ipt_netflow_sndbuf_peak 19
        # HELP ipt_netflow_socket_active Connection state of this socket.
        # TYPE ipt_netflow_socket_active counter
        ipt_netflow_socket_active{destination="localhost:1234",socket="sock0"} 1
        # HELP ipt_netflow_socket_error_cberr Asynchronous callback errors on this socket. Usually mean that there is 'connection refused' errors on UDP socket reported via ICMP messages.
        # TYPE ipt_netflow_socket_error_cberr counter
        ipt_netflow_socket_error_cberr{destination="localhost:1234",socket="sock0"} 4
        # HELP ipt_netflow_socket_error_connect Connections attempt count. High value usually mean that network is not set up properly, or module is loaded before network is up, in this case it is not dangerousand should be ignored.
        # TYPE ipt_netflow_socket_error_connect counter
        ipt_netflow_socket_error_connect{destination="localhost:1234",socket="sock0"} 2
        # HELP ipt_netflow_socket_error_full Socket full errors on this socket. Usually mean sndbuf value is too small.
        # TYPE ipt_netflow_socket_error_full counter
        ipt_netflow_socket_error_full{destination="localhost:1234",socket="sock0"} 3
        # HELP ipt_netflow_socket_error_other All other possible errors on this socket.
        # TYPE ipt_netflow_socket_error_other counter
        ipt_netflow_socket_error_other{destination="localhost:1234",socket="sock0"} 5
        # HELP ipt_netflow_socket_snd_buf Sndbuf value for this socket. Higher value allows accommodate (exporting) traffic bursts.
        # TYPE ipt_netflow_socket_snd_buf gauge
        ipt_netflow_socket_snd_buf{destination="localhost:1234",socket="sock0"} 6
        # HELP ipt_netflow_socket_snd_buf_fill Amount of data currently in socket buffers. When this value will reach size sndbuf, packet loss will occur.
        # TYPE ipt_netflow_socket_snd_buf_fill gauge
        ipt_netflow_socket_snd_buf_fill{destination="localhost:1234",socket="sock0"} 7
        # HELP ipt_netflow_socket_snd_buf_peak Historical peak amount of data in socket buffers. Useful to evaluate sndbuf size, because sockSndbufFill is transient.
        # TYPE ipt_netflow_socket_snd_buf_peak gauge
        ipt_netflow_socket_snd_buf_peak{destination="localhost:1234",socket="sock0"} 8
        `
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by mockery v2.52.3. DO NOT EDIT.

package mocks

import (
        statparser "github.com/mythvcode/ipt-netflow-exporter/internal/statparser"
        mock "github.com/stretchr/testify/mock"
)

// MockStatParser is an autogenerated mock type for the StatParser type
type MockStatParser struct {
        mock.Mock
}

type MockStatParser_Expecter struct {
        mock *mock.Mock
}

func (_m *MockStatParser) EXPECT() *MockStatParser_Expecter <span class="cov0" title="0">{
        return &amp;MockStatParser_Expecter{mock: &amp;_m.Mock}
}</span>

// CollectAndMarshal provides a mock function with no fields
func (_m *MockStatParser) CollectAndMarshal() (statparser.Statistics, error) <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CollectAndMarshal")</span>
        }

        <span class="cov0" title="0">var r0 statparser.Statistics
        var r1 error
        if rf, ok := ret.Get(0).(func() (statparser.Statistics, error)); ok </span><span class="cov0" title="0">{
                return rf()
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func() statparser.Statistics); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(statparser.Statistics)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func() error); ok </span><span class="cov0" title="0">{
                r1 = rf()
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// MockStatParser_CollectAndMarshal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CollectAndMarshal'
type MockStatParser_CollectAndMarshal_Call struct {
        *mock.Call
}

// CollectAndMarshal is a helper method to define mock.On call
func (_e *MockStatParser_Expecter) CollectAndMarshal() *MockStatParser_CollectAndMarshal_Call <span class="cov0" title="0">{
        return &amp;MockStatParser_CollectAndMarshal_Call{Call: _e.mock.On("CollectAndMarshal")}
}</span>

func (_c *MockStatParser_CollectAndMarshal_Call) Run(run func()) *MockStatParser_CollectAndMarshal_Call <span class="cov0" title="0">{
        _c.Call.Run(func(args mock.Arguments) </span><span class="cov0" title="0">{
                run()
        }</span>)
        <span class="cov0" title="0">return _c</span>
}

func (_c *MockStatParser_CollectAndMarshal_Call) Return(_a0 statparser.Statistics, _a1 error) *MockStatParser_CollectAndMarshal_Call <span class="cov0" title="0">{
        _c.Call.Return(_a0, _a1)
        return _c
}</span>

func (_c *MockStatParser_CollectAndMarshal_Call) RunAndReturn(run func() (statparser.Statistics, error)) *MockStatParser_CollectAndMarshal_Call <span class="cov0" title="0">{
        _c.Call.Return(run)
        return _c
}</span>

// NewMockStatParser creates a new instance of MockStatParser. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStatParser(t interface {
        mock.TestingT
        Cleanup(func())
}) *MockStatParser <span class="cov0" title="0">{
        mock := &amp;MockStatParser{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov0" title="0">{ mock.AssertExpectations(t) }</span>)

        <span class="cov0" title="0">return mock</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package exporter

import (
        "github.com/mythvcode/ipt-netflow-exporter/internal/statparser"
        "github.com/prometheus/client_golang/prometheus"
)

const (
        socketNameLabel = "socket"
        socketDstLabel  = "destination"
)

type SockMetrics struct {
        sockActive     *prometheus.CounterVec
        sockErrConnect *prometheus.CounterVec
        sockErrFull    *prometheus.CounterVec
        sockErrCberr   *prometheus.CounterVec
        sockErrOther   *prometheus.CounterVec
        sockSndbuf     *prometheus.GaugeVec
        sockSndbufFill *prometheus.GaugeVec
        sockSndbufPeak *prometheus.GaugeVec
}

func newSocketMetrics() *SockMetrics <span class="cov8" title="1">{
        return &amp;SockMetrics{
                sockActive: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "socket_active",
                                Help:      "Connection state of this socket.",
                        }, []string{socketNameLabel, socketDstLabel},
                ),
                sockErrConnect: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "socket_error_connect",
                                Help: "Connections attempt count. High value usually mean " +
                                        "that network is not set up properly, or module is loaded " +
                                        "before network is up, in this case it is not dangerous" +
                                        "and should be ignored.",
                        }, []string{socketNameLabel, socketDstLabel},
                ),
                sockErrFull: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "socket_error_full",
                                Help:      "Socket full errors on this socket. Usually mean sndbuf value is too small.",
                        }, []string{socketNameLabel, socketDstLabel},
                ),
                sockErrCberr: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "socket_error_cberr",
                                Help: "Asynchronous callback errors on this socket. Usually mean " +
                                        "that there is 'connection refused' errors on UDP socket " +
                                        "reported via ICMP messages.",
                        }, []string{socketNameLabel, socketDstLabel},
                ),
                sockErrOther: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Namespace: metricsNamespace,
                                Name:      "socket_error_other",
                                Help:      "All other possible errors on this socket.",
                        }, []string{socketNameLabel, socketDstLabel},
                ),
                sockSndbuf: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Namespace: metricsNamespace,
                                Name:      "socket_snd_buf",
                                Help:      "Sndbuf value for this socket. Higher value allows accommodate (exporting) traffic bursts.",
                        }, []string{socketNameLabel, socketDstLabel},
                ),
                sockSndbufFill: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Namespace: metricsNamespace,
                                Name:      "socket_snd_buf_fill",
                                Help: "Amount of data currently in socket buffers. When this value " +
                                        "will reach size sndbuf, packet loss will occur.",
                        }, []string{socketNameLabel, socketDstLabel},
                ),
                sockSndbufPeak: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Namespace: metricsNamespace,
                                Name:      "socket_snd_buf_peak",
                                Help: "Historical peak amount of data in socket buffers. Useful to " +
                                        "evaluate sndbuf size, because sockSndbufFill is transient.",
                        }, []string{socketNameLabel, socketDstLabel},
                ),
        }
}</span>

func (c *SockMetrics) metricList() []iptNetFlowMetric <span class="cov8" title="1">{
        return []iptNetFlowMetric{
                c.sockActive,
                c.sockErrConnect,
                c.sockErrFull,
                c.sockErrCberr,
                c.sockErrOther,
                c.sockSndbuf,
                c.sockSndbufFill,
                c.sockSndbufPeak,
        }
}</span>

func (c *SockMetrics) reset() <span class="cov8" title="1">{
        for _, metric := range c.metricList() </span><span class="cov8" title="1">{
                metric.Reset()
        }</span>
}

func (c *SockMetrics) updateValues(stat *statparser.Statistics) <span class="cov8" title="1">{
        c.reset()

        for _, sockStat := range stat.SockStatList </span><span class="cov8" title="1">{
                c.sockActive.With(
                        prometheus.Labels{
                                socketNameLabel: sockStat.SockName,
                                socketDstLabel:  sockStat.SockDestination,
                        }).Add(float64(sockStat.SockActive))
                c.sockErrConnect.With(
                        prometheus.Labels{
                                socketNameLabel: sockStat.SockName,
                                socketDstLabel:  sockStat.SockDestination,
                        }).Add(float64(sockStat.SockErrConnect))
                c.sockErrFull.With(
                        prometheus.Labels{
                                socketNameLabel: sockStat.SockName,
                                socketDstLabel:  sockStat.SockDestination,
                        }).Add(float64(sockStat.SockErrFull))
                c.sockErrCberr.With(
                        prometheus.Labels{
                                socketNameLabel: sockStat.SockName,
                                socketDstLabel:  sockStat.SockDestination,
                        }).Add(float64(sockStat.SockErrCberr))
                c.sockErrOther.With(
                        prometheus.Labels{
                                socketNameLabel: sockStat.SockName,
                                socketDstLabel:  sockStat.SockDestination,
                        }).Add(float64(sockStat.SockErrOther))
                c.sockSndbuf.With(
                        prometheus.Labels{
                                socketNameLabel: sockStat.SockName,
                                socketDstLabel:  sockStat.SockDestination,
                        }).Set(float64(sockStat.SockSndbuf))
                c.sockSndbufFill.With(
                        prometheus.Labels{
                                socketNameLabel: sockStat.SockName,
                                socketDstLabel:  sockStat.SockDestination,
                        }).Set(float64(sockStat.SockSndbufFill))
                c.sockSndbufPeak.With(
                        prometheus.Labels{
                                socketNameLabel: sockStat.SockName,
                                socketDstLabel:  sockStat.SockDestination,
                        }).Set(float64(sockStat.SockSndbufPeak))
        }</span>
}

func (c *SockMetrics) Describe(ch chan&lt;- *prometheus.Desc) <span class="cov8" title="1">{
        for _, metric := range c.metricList() </span><span class="cov8" title="1">{
                metric.Describe(ch)
        }</span>
}

func (c *SockMetrics) Collect(metricChan chan&lt;- prometheus.Metric) <span class="cov8" title="1">{
        for _, metric := range c.metricList() </span><span class="cov8" title="1">{
                metric.Collect(metricChan)
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package logger

import (
        "context"
        "log/slog"
)

type discardHandler struct {
        slog.JSONHandler
}

func (discardHandler) Enabled(context.Context, slog.Level) bool <span class="cov0" title="0">{
        return false
}</span>

func (discardHandler) Handle(context.Context, slog.Record) error <span class="cov0" title="0">{
        return nil
}</span>

func (h discardHandler) WithAttrs([]slog.Attr) slog.Handler <span class="cov0" title="0">{
        return h
}</span>

func (h discardHandler) WithGroup(string) slog.Handler <span class="cov0" title="0">{
        return h
}</span>

func SetDefaultDiscardLogger() <span class="cov0" title="0">{
        slog.SetDefault(slog.New(&amp;discardHandler{}))
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package logger

import (
        "fmt"
        "log/slog"
        "os"
        "path/filepath"

        slogmulti "github.com/samber/slog-multi"
)

const Component = "component"

type Logger struct {
        logger *slog.Logger
}

func marshalLevel(level string) (slog.Level, error) <span class="cov0" title="0">{
        if level == "" </span><span class="cov0" title="0">{
                return slog.LevelDebug, nil
        }</span>
        <span class="cov0" title="0">var l slog.Level
        err := l.UnmarshalText([]byte(level))

        return l, err</span>
}

func getHandler(format string, logFile *os.File, level slog.Level) slog.Handler <span class="cov0" title="0">{
        if format == "text" </span><span class="cov0" title="0">{
                return slog.NewTextHandler(logFile, &amp;slog.HandlerOptions{Level: level})
        }</span>

        <span class="cov0" title="0">return slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{Level: level})</span>
}

func Init(logFile string, level string, format string) error <span class="cov0" title="0">{
        parsedLevel, err := marshalLevel(level)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">slogHandlers := make([]slog.Handler, 0, 2)
        var slogHandler slog.Handler
        if logFile != "" </span><span class="cov0" title="0">{
                logFile, err := os.OpenFile(filepath.Clean(logFile), os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0o644)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to initialize log file %w", err)
                }</span>
                <span class="cov0" title="0">slogHandler = getHandler(format, logFile, parsedLevel)</span>
        } else<span class="cov0" title="0"> {
                slogHandler = getHandler(format, os.Stdout, parsedLevel)
        }</span>

        <span class="cov0" title="0">slogHandlers = append(slogHandlers, slogHandler)

        logger := slog.New(slogmulti.Fanout(slogHandlers...))

        slog.SetDefault(logger)

        return nil</span>
}

func Default() *Logger <span class="cov0" title="0">{
        return &amp;Logger{
                slog.New(slog.NewJSONHandler(os.Stdout,
                        &amp;slog.HandlerOptions{Level: slog.LevelInfo})),
        }
}</span>

func GetLogger() *Logger <span class="cov0" title="0">{
        return &amp;Logger{slog.Default()}
}</span>

func (l *Logger) With(args ...any) *Logger <span class="cov0" title="0">{
        return &amp;Logger{l.logger.With(args...)}
}</span>

func (l *Logger) Debugf(fsting string, formaters ...any) <span class="cov0" title="0">{
        l.logger.Debug(fmt.Sprintf(fsting, formaters...))
}</span>

func (l *Logger) Infof(fsting string, formaters ...any) <span class="cov0" title="0">{
        l.logger.Info(fmt.Sprintf(fsting, formaters...))
}</span>

func (l *Logger) Warningf(fsting string, formaters ...any) <span class="cov0" title="0">{
        l.logger.Warn(fmt.Sprintf(fsting, formaters...))
}</span>

func (l *Logger) Errorf(fsting string, formaters ...any) <span class="cov0" title="0">{
        l.logger.Error(fmt.Sprintf(fsting, formaters...))
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package statparser

import (
        "errors"
        "fmt"
        "reflect"
        "strconv"
        "unicode"
)

const (
        cpuStatFieldsCount  = 12
        sockStatFieldsCount = 10
)

var (
        errNotFoundField   = errors.New("stat field not found")
        errUpdate          = errors.New("struct field cannot be updated")
        errUnsupportedType = errors.New("unsupported type")
)

type statType interface {
        fieldCount() int
        typeName() string
}

// metric with names from stats files
type Statistics struct {
        InBitRate    uint64
        InPacketRate uint64
        InFlows      uint64
        InPackets    uint64
        InBytes      uint64
        HashMetric   float64
        HashMemory   uint64
        HashFlows    uint64
        HashPackets  uint64
        HashBytes    uint64
        DropPackets  uint64
        DropBytes    uint64
        OutByteRate  uint64
        OutFlows     uint64
        OutPackets   uint64
        OutBytes     uint64
        LostFlows    uint64
        LostPackets  uint64
        LostBytes    uint64
        ErrTotal     uint64
        SndbufPeak   uint64
        CPUStatList  []CPUStat
        SockStatList []NFSockEntry
}

// Order of fields must be the same as in pt_netflow_snmp
type CPUStat struct {
        CPU             string
        CPUInPacketRate uint64
        CPUInFlows      uint64
        CPUInPackets    uint64
        CPUInBytes      uint64
        CPUHashMetric   float64
        CPUDropPackets  uint64
        CPUuDropBytes   uint64
        CPUErrTrunc     uint64
        CPUErrFrag      uint64
        CPUErrAlloc     uint64
        CPUErrMaxflows  uint64
}

// Order of fields must be the same as in pt_netflow_snmp
type NFSockEntry struct {
        SockName        string
        SockDestination string
        SockActive      uint32
        SockErrConnect  uint32
        SockErrFull     uint32
        SockErrCberr    uint32
        SockErrOther    uint32
        SockSndbuf      uint32
        SockSndbufFill  uint32
        SockSndbufPeak  uint32
}

func (c *CPUStat) fieldCount() int <span class="cov8" title="1">{
        return cpuStatFieldsCount
}</span>

func (c *CPUStat) typeName() string <span class="cov8" title="1">{
        return "cpu"
}</span>

func (c *NFSockEntry) fieldCount() int <span class="cov8" title="1">{
        return sockStatFieldsCount
}</span>

func (c *NFSockEntry) typeName() string <span class="cov0" title="0">{
        return "socket"
}</span>

func toUpperFirstChar(str string) string <span class="cov8" title="1">{
        if len(str) == 0 </span><span class="cov0" title="0">{
                return str
        }</span>
        <span class="cov8" title="1">runes := []rune(str)
        runes[0] = unicode.ToUpper(runes[0])

        return string(runes)</span>
}

func checkStructField(structField reflect.Value) error <span class="cov8" title="1">{
        if !structField.IsValid() </span><span class="cov8" title="1">{
                return errNotFoundField
        }</span>

        <span class="cov8" title="1">if !structField.CanSet() </span><span class="cov0" title="0">{
                return errUpdate
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// parses value according to field type and return parsed value as reflect.Value
func getValueByType(field reflect.Value, value string) (reflect.Value, error) <span class="cov8" title="1">{
        switch field.Kind() </span>{ //nolint
        case reflect.Uint64:<span class="cov8" title="1">
                intVal, err := strconv.ParseUint(value, 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return reflect.Value{}, err
                }</span>

                <span class="cov8" title="1">return reflect.ValueOf(intVal), nil</span>
        case reflect.Float64:<span class="cov8" title="1">
                floatVal, err := strconv.ParseFloat(value, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return reflect.Value{}, err
                }</span>

                <span class="cov8" title="1">return reflect.ValueOf(floatVal), nil</span>
        case reflect.Uint32:<span class="cov8" title="1">
                intVal, err := strconv.ParseUint(value, 10, 32)
                if err != nil </span><span class="cov8" title="1">{
                        return reflect.Value{}, err
                }</span>

                <span class="cov8" title="1">return reflect.ValueOf(uint32(intVal)), nil</span>

        case reflect.String:<span class="cov8" title="1">

                return reflect.ValueOf(value), nil</span>

        default:<span class="cov8" title="1">
                return reflect.Value{}, errUnsupportedType</span>
        }
}

func setValueByName(stat *Statistics, metricName, value string) error <span class="cov8" title="1">{
        structVal := reflect.ValueOf(stat).Elem()
        structField := structVal.FieldByName(toUpperFirstChar(metricName))
        if err := checkStructField(structField); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">val, err := getValueByType(structField, value)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, errUnsupportedType) </span><span class="cov0" title="0">{
                        return fmt.Errorf("error unsupported field name type: field %s, type: %s", toUpperFirstChar(metricName), structField.Kind().String())
                }</span>

                <span class="cov8" title="1">return err</span>
        }
        <span class="cov8" title="1">structField.Set(val)

        return nil</span>
}

func setValues(stat statType, fields []string) error <span class="cov8" title="1">{
        if len(fields) != stat.fieldCount() </span><span class="cov8" title="1">{
                return fmt.Errorf("error parse fields count for %s stat: must be %d, actual %d", stat.typeName(), stat.fieldCount(), len(fields))
        }</span>
        <span class="cov8" title="1">structVal := reflect.ValueOf(stat).Elem()
        if !structVal.IsValid() </span><span class="cov0" title="0">{
                return fmt.Errorf("error value of stat parameter")
        }</span>

        <span class="cov8" title="1">for index, rawValue := range fields </span><span class="cov8" title="1">{
                structField := structVal.Field(index)
                if err := checkStructField(structField); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">val, err := getValueByType(structField, rawValue)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, errUnsupportedType) </span><span class="cov0" title="0">{
                                return fmt.Errorf("error parse field type: position %d, type: %s", index, structField.Kind().String())
                        }</span>

                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov8" title="1">structField.Set(val)</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package statparser

import (
        "bytes"
        "errors"
        "log/slog"
        "os"
        "regexp"
        "strings"

        "github.com/mythvcode/ipt-netflow-exporter/internal/logger"
)

var readFile = os.ReadFile

var (
        isCPUStat    = regexp.MustCompile(`^cpu\d+$`).MatchString
        isSocketStat = regexp.MustCompile(`^sock\d+$`).MatchString
)

type StatCollector struct {
        filepath string
        log      *logger.Logger
}

func New(statPath string) *StatCollector <span class="cov8" title="1">{
        return &amp;StatCollector{
                filepath: statPath,
                log:      logger.GetLogger().With(slog.String(logger.Component, "StatCollector")),
        }
}</span>

func readStatFile(filePath string) ([]string, error) <span class="cov8" title="1">{
        result := make([]string, 0, 30)
        fileContent, err := readFile(filePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">for _, line := range bytes.Split(fileContent, []byte("\n")) </span><span class="cov8" title="1">{
                result = append(result, string(line))
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

func (s *StatCollector) CollectAndMarshal() (Statistics, error) <span class="cov8" title="1">{
        file, err := readStatFile(s.filepath)
        if err != nil </span><span class="cov8" title="1">{
                return Statistics{}, err
        }</span>

        <span class="cov8" title="1">return s.parseFields(file)</span>
}

func (s *StatCollector) parseFields(fileLines []string) (Statistics, error) <span class="cov8" title="1">{
        resultStruct := Statistics{}
        for _, line := range fileLines </span><span class="cov8" title="1">{
                if splitLine := strings.Fields(line); len(splitLine) &gt; 0 </span><span class="cov8" title="1">{
                        if err := s.processConfigLine(&amp;resultStruct, splitLine); err != nil </span><span class="cov8" title="1">{
                                return resultStruct, err
                        }</span>
                }
        }

        <span class="cov8" title="1">return resultStruct, nil</span>
}

func (s *StatCollector) processConfigLine(statStruct *Statistics, splitLine []string) error <span class="cov8" title="1">{
        if isCPUStat(splitLine[0]) </span><span class="cov8" title="1">{
                if res := s.parseCPUFields(splitLine); res != nil </span><span class="cov8" title="1">{
                        statStruct.CPUStatList = append(statStruct.CPUStatList, *res)
                }</span>
                // do not return errors for specific metrics
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">if isSocketStat(splitLine[0]) </span><span class="cov8" title="1">{
                if res := s.parseSocketFields(splitLine); res != nil </span><span class="cov8" title="1">{
                        statStruct.SockStatList = append(statStruct.SockStatList, *res)
                }</span>
                // do not return errors for specific metrics
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">if err := setValueByName(statStruct, splitLine[0], splitLine[1]); err != nil </span><span class="cov8" title="1">{
                if errors.Is(errNotFoundField, err) </span><span class="cov0" title="0">{
                        s.log.Debugf("found unsupported metrics in ipt_NETFLOW stat file: metric %s", splitLine[0])
                }</span> else<span class="cov8" title="1"> {
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (s *StatCollector) parseCPUFields(cpuFields []string) *CPUStat <span class="cov8" title="1">{
        result := CPUStat{}
        if err := setValues(&amp;result, cpuFields); err != nil </span><span class="cov8" title="1">{
                s.log.Errorf("%s", err.Error())

                return nil
        }</span>

        <span class="cov8" title="1">return &amp;result</span>
}

func (s *StatCollector) parseSocketFields(cpuFields []string) *NFSockEntry <span class="cov8" title="1">{
        result := NFSockEntry{}
        if err := setValues(&amp;result, cpuFields); err != nil </span><span class="cov0" title="0">{
                s.log.Errorf("%s", err.Error())

                return nil
        }</span>

        <span class="cov8" title="1">return &amp;result</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
